package main

import (
	"encoding/xml"
	"log"
	"os"
	"path/filepath"
	"sort"
	"text/template"
	"time"
)

var (
	types         = make(map[string]*ParsedMIMEType)
	typesTemplate = template.Must(template.New("").Parse( /*`// Code generated by mimemagic. DO NOT EDIT.
		// Generated at {{ .Timestamp }}
		// using data from {{ .Directory }}*/
		`package mimemagic

const (
	unknownType      = {{ .OctetStream }}
	emptyDocument    = {{ .ZeroSize }}
	plainText        = {{ .PlainText }}
	unknownDirectory = {{ .Dir }}
	unknownXML       = {{ .XML }}
)

var mediaTypes = []MediaType{
{{- range .TypeSlice }}
	{{ printf "%s" (index $.Types .)  }},
{{- end }}
}
`))
	typeSlice       = make([]string, 0)
	identifierSlice = make(IdentifierSlice, 0)
	suffixMap       = make(map[string]weightedMIMESlice)
	csSuffixMap     = make(map[string]weightedMIMESlice)
	prefixMap       = make(map[string]weightedMIMESlice)
	csPrefixMap     = make(map[string]weightedMIMESlice)
	textMap         = make(map[string]weightedMIMESlice)
	csTextMap       = make(map[string]weightedMIMESlice)
	patternSlice    = make(IdentifierSlice, 0)

	identifiersTemplate = template.Must(template.New("").Parse( /*`// Code generated by mimemagic. DO NOT EDIT.
		// Generated at {{ .Timestamp }}
		// using data from {{ .Directory }}*/
		`package mimemagic

const globMaxLen = {{ .MaxLen }}

var globs = []glob{
{{- range .Patterns }}
	{{ printf "%s" . }},
{{- end }}
}

var suffixes = map[string][]simpleGlob{
{{- range $k, $v := .Suffix }}
	{{ printf "%q: %#v" $k $v }},
{{- end }}
}

var suffixesCS = map[string][]simpleGlob{
{{- range $k, $v := .CaseSensitiveSuffix }}
	{{ printf "%q: %#v" $k $v }},
{{- end }}
}

var prefixes = map[string][]simpleGlob{
{{- range $k, $v := .Prefix }}
	{{ printf "%q: %#v" $k $v }},
{{- end }}
}

var prefixesCS = map[string][]simpleGlob{
{{- range $k, $v := .CaseSensitivePrefix }}
	{{ printf "%q: %#v" $k $v }},
{{- end }}
}

var text = map[string][]simpleGlob{
{{- range $k, $v := .Text }}
	{{ printf "%q: %#v" $k $v }},
{{- end }}
}

var textCS = map[string][]simpleGlob{
{{- range $k, $v := .CaseSensitiveText }}
	{{ printf "%q: %#v" $k $v }},
{{- end }}
}
`))
	magicSlice    = make(MagicSlice, 0)
	magicTemplate = template.Must(template.New("").Parse( /*`// Code generated by mimemagic. DO NOT EDIT.
		// Generated at {{ .Timestamp }}
		// using data from {{ .Directory }}*/
		`package mimemagic

const magicMaxLen = {{ .MaxLen }}

var magicSignatures = []magic{
{{- range .Magic }}
	{{ printf "%s" . }},
{{- end }}
}
`))
	treeMagicSlice    = make(TreeMagicSlice, 0)
	treeMagicTemplate = template.Must(template.New("").Parse( /*`// Code generated by mimemagic. DO NOT EDIT.
		// Generated at {{ .Timestamp }}
		// using data from {{ .Directory }}*/
		`package mimemagic

var treeMagicSignatures = []treeMagic{
{{- range .TreeMagic }}
	{{ printf "%s" . }},
{{- end }}
}
`))
	rootXMLSlice    = make(RootXMLSLice, 0)
	rootXMLTemplate = template.Must(template.New("").Parse( /*`// Code generated by mimemagic. DO NOT EDIT.
		// Generated at {{ .Timestamp }}
		// using data from {{ .Directory }}*/
		`package mimemagic

var namespaces = []namespace{
{{- range .RootXML }}
	{{ printf "%s" . }},
{{- end }}
}
`))
	aliases = make(map[string]string)
	dir     = "./generator"
)

func insertType(mi ParsedMIMEInfo) {
	for _, mt := range mi {
		if ot, ok := types[mt.Media+"/"+mt.Subtype]; ok {
			ot.Merge(mt)
		} else {
			found := false
			for _, a := range mt.Alias {
				if ot, ok = types[a]; ok {
					ot.Merge(mt)
					found = true
					break
				}
			}
			if !found {
				for _, ot := range types {
					for _, a := range ot.Alias {
						if a == mt.Media+"/"+mt.Subtype {
							ot.Merge(mt)
							found = true
							break
						}
						for _, aa := range mt.Alias {
							if a == aa {
								ot.Merge(mt)
								found = true
								break
							}
						}
					}
				}
			}
			if !found {
				types[mt.Media+"/"+mt.Subtype] = mt
			}
		}
	}
}

func main() {
	if dir == "" {
		dir = "./parser"
	}
	files, err := filepath.Glob(dir + "/*.xml")
	if err != nil {
		log.Fatalf("invalid directory name %s: %v\n", dir, err)
	}
	abs, _ := filepath.Abs(dir)
	if len(files) < 1 {
		log.Fatalf("no *.xml files found")
	}
	var f *os.File
	switch f, err = os.Open(dir + "/freedesktop.org.xml"); {
	case err == nil:
		m := &MIMEInfo{}
		if err = xml.NewDecoder(f).Decode(m); err != nil {
			f.Close()
			log.Fatalf("couldn't unmarshal xml in file freedesktop.org.xml: %v\n", err)
		}
		var p ParsedMIMEInfo
		if p, err = ParseMIMEInfo(m); err != nil {
			f.Close()
			log.Fatalf("couldn't parse MIME info in file freedesktop.org.xml: %v\n", err)
		}
		insertType(p)
		f.Close()
	case os.IsNotExist(err):
		break
	default:
		log.Fatalf("couldn't open file freedesktop.org.xml: %v\n", err)
	}
	var override ParsedMIMEInfo
	for _, filename := range files {
		fn := filepath.Base(filename)
		if fn == "freedesktop.org.xml" {
			continue
		}
		f, err = os.Open(filename)
		if err != nil {
			log.Fatalf("couldn't open file %s: %v\n", fn, err)
		}
		m := &MIMEInfo{}
		if err = xml.NewDecoder(f).Decode(m); err != nil {
			f.Close()
			log.Fatalf("couldn't unmarshal xml in file %s: %v\n", fn, err)
		}
		var p ParsedMIMEInfo
		if p, err = ParseMIMEInfo(m); err != nil {
			f.Close()
			log.Fatalf("couldn't parse MIME info in file %s: %v\n", fn, err)
		}
		if fn == "Override.xml" {
			override = p
		} else {
			insertType(p)
		}
		f.Close()
	}
	if override != nil {
		insertType(override)
	}
	if _, ok := types["application/octet-stream"]; !ok {
		types["application/octet-stream"] = &ParsedMIMEType{
			Media:   "application",
			Subtype: "octet-stream",
			Comment: "unknown",
		}
	}
	if _, ok := types["application/x-zerosize"]; !ok {
		types["application/x-zerosize"] = &ParsedMIMEType{
			Media:   "application",
			Subtype: "x-zerosize",
			Comment: "empty document",
		}
	}
	if _, ok := types["text/plain"]; !ok {
		types["text/plain"] = &ParsedMIMEType{
			Media:   "text",
			Subtype: "plain",
			Comment: "plain text document",
		}
	}
	if _, ok := types["application/xml"]; !ok {
		types["application/xml"] = &ParsedMIMEType{
			Media:   "application",
			Subtype: "xml",
			Comment: "XML document",
		}
	}
	if _, ok := types["inode/directory"]; !ok {
		types["inode/directory"] = &ParsedMIMEType{
			Media:   "inode",
			Subtype: "directory",
			Comment: "folder",
		}
	}
	octet, zerosize, plain, directory, xmltype := 0, 0, 0, 0, 0
	for t := range types {
		typeSlice = append(typeSlice, t)
	}
	sort.Strings(typeSlice)
	maxLen := 0
	for i, t := range typeSlice {
		types[t].Lexicographic = i
		switch t {
		case "text/plain":
			plain = i
		case "application/x-zerosize":
			zerosize = i
		case "application/octet-stream":
			octet = i
		case "inode/directory":
			directory = i
		case "application/xml":
			xmltype = i
		}
		for _, g := range types[t].Glob {
			gg, err := GlobMatcher(g, i)
			if err != nil {
				log.Fatalf("%s, %v\n", g.Pattern, err)
			}
			identifierSlice = append(identifierSlice, gg)
		}
		for _, m := range types[t].Magic {
			m.MIMEType = i
			magicSlice = append(magicSlice, m)
			if l := m.MaxLen(); l > maxLen {
				maxLen = l
			}
		}
		for _, x := range types[t].RootXML {
			x.MIMEType = i
			rootXMLSlice = append(rootXMLSlice, x)
		}
		for _, m := range types[t].TreeMagic {
			m.MIMEType = i
			treeMagicSlice = append(treeMagicSlice, m)
		}
		for _, a := range types[t].Alias {
			aliases[a] = t
		}
	}
	sort.Sort(identifierSlice)
	globMaxLen := identifierSlice.GenerateMaps()
	sort.Sort(magicSlice)
	sort.Sort(treeMagicSlice)
	//sort.Sort(rootXMLSlice)
	f, err = os.Create("mediatypes.go")
	if err != nil {
		log.Fatalf("couldn't create file: %v\n", err)
	}
	err = typesTemplate.Execute(f, struct {
		Timestamp             time.Time
		Directory             string
		Types                 map[string]*ParsedMIMEType
		TypeSlice             []string
		ZeroSize, OctetStream int
		PlainText, Dir, XML   int
	}{
		Timestamp:   time.Now(),
		Directory:   abs,
		Types:       types,
		TypeSlice:   typeSlice,
		ZeroSize:    zerosize,
		OctetStream: octet,
		PlainText:   plain,
		Dir:         directory,
		XML:         xmltype,
	})
	f.Close()
	if err != nil {
		log.Fatalf("couldn't generate mediatypes.go: %v\n", err)
	}
	f, err = os.Create("globs.go")
	if err != nil {
		log.Fatalf("couldn't create file: %v\n", err)
	}
	err = identifiersTemplate.Execute(f, struct {
		Timestamp                                                                         time.Time
		Directory                                                                         string
		Patterns                                                                          IdentifierSlice
		Suffix, Prefix, Text, CaseSensitiveSuffix, CaseSensitivePrefix, CaseSensitiveText map[string]weightedMIMESlice
		MaxLen                                                                            int
	}{
		Timestamp:           time.Now(),
		Directory:           abs,
		Patterns:            patternSlice,
		Suffix:              suffixMap,
		Prefix:              prefixMap,
		Text:                textMap,
		CaseSensitiveSuffix: csSuffixMap,
		CaseSensitivePrefix: csPrefixMap,
		CaseSensitiveText:   csTextMap,
		MaxLen:              globMaxLen,
	})
	f.Close()
	if err != nil {
		log.Fatalf("couldn't generate globs.go: %v\n", err)
	}
	f, err = os.Create("magicsigs.go")
	if err != nil {
		log.Fatalf("couldn't create file: %v\n", err)
	}
	err = magicTemplate.Execute(f, struct {
		Timestamp time.Time
		Directory string
		Magic     MagicSlice
		MaxLen    int
	}{
		Timestamp: time.Now(),
		Directory: abs,
		Magic:     magicSlice,
		MaxLen:    maxLen,
	})
	f.Close()
	if err != nil {
		log.Fatalf("couldn't generate magicsigs.go: %v\n", err)
	}
	f, err = os.Create("treemagicsigs.go")
	if err != nil {
		log.Fatalf("couldn't create file: %v\n", err)
	}
	err = treeMagicTemplate.Execute(f, struct {
		Timestamp time.Time
		Directory string
		TreeMagic TreeMagicSlice
	}{
		Timestamp: time.Now(),
		Directory: abs,
		TreeMagic: treeMagicSlice,
	})
	f.Close()
	if err != nil {
		log.Fatalf("couldn't generate treemagicsigs.go: %v\n", err)
	}
	f, err = os.Create("namespaces.go")
	if err != nil {
		log.Fatalf("couldn't create file: %v\n", err)
	}
	err = rootXMLTemplate.Execute(f, struct {
		Timestamp time.Time
		Directory string
		RootXML   RootXMLSLice
	}{
		Timestamp: time.Now(),
		Directory: abs,
		RootXML:   rootXMLSlice,
	})
	f.Close()
	if err != nil {
		log.Fatalf("couldn't generate namespaces.go: %v\n", err)
	}
}
